# Chapter 9 Modules 

模块是一种将方法、类和常量组织在一起的方式，主要为了

- 提供命名空间
- 实现mixin功能

---
<br>
#### 命名空间 
 同类方法一样，用模块名和据点调用模块方法，使用模块名和::来引用常量
 
---
<br>
#### Mixin

- Mix in (混入)的模块其实际行为就像是一个超类
- Ruby的include并非简单地将模块的实例方法拷贝到类中，相反，它建立一个由类到所包含谋爱的引用。如果多个类包含这个模块，它们都指向相同的内容。
- Mixin为你向类中添加功能，提供了一种控制精巧的方式。不过，它们真正的力量，当mixin中的代码和使用它的类中的代码开始交互时，才会显现出来。
- 多数时候，mixin模块并不带有它们自己的实例数据——它们只是使用访问方法从客户对象中取得数据。但是如果你要创建的mixin不得不持有它们自己的状态。确保这个实例变量具有唯一的名字，可以对系统中其他的minxi区别开来（也许使用模块名作为变量的一部分）。或者，模块可以使用模块一级的散列表，以当前对象的ID作为索引，来保存特定与实例的数据，而不使用Ruby的实例变量

```ruby
module Test
	State = {}
	def state=(value)
		State[object_id] = value
	end
	def state
		State[object_id]
	end
end

class Client
	include Test
end

c1 = Client.new
c2 = Client.new
c1.state = 'cat'
c2.state = 'dog'
c1.state 
c2.state
```

- 当类包含一个模块时，模块的实例就变为类的实例方法。就好像模块变成类的超类。Ruby创建了一个指向该模块的匿名代理类，并将这个代理插入到实施包含的类中作为其直接超类。代理类包含有指向模块实例变量和实例方法的引用。
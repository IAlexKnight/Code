# Chapter 3  无类型语言crowbar

### 符号表与扣留操作
crowbar对于程序中多次出现的变量名等，会分别开辟空间将其保存。如果变量名比较长时比较浪费，因此将同名变量整合为一处保存，不失为一个提高效率的方法。  
具体来说，程序中会存在一个函数，为所有出现的特政符建立数据结构，新特政符如果已经被记录则会返回其指针，如果尚未记录则会新录入并返回其指针。这样的操作成为扣留（intern）。对一个标识符进行扣留操作时，无需判别该标识符是局部变量还是全局变量，伙食函数名（当然进行判别也无妨）。  
对程序中出现的所有的标识符——进行扣留操作的话，在判断两个标识符是否为同一个时，可以直接比较它们的指针，这比strcmp()速度会更快。  
而crowbar对于局部变量、全局变量和函数则分别使用链表进行管理。一旦语句中出现变量名时，将从链表头部开始检索（线性检索），当然有多种数据结构可以用来进行优化。

---

### 不完全类型
CRB_Interpreter类型结构体是在crowbar的私有头文件crowbar.h中定义的。不过这是供解释器内部使用的数据结构，不应该向外部公开。  
而生成解释器的函数 ``` CRB_create_interpreter() ```，它的原型定义则是在公有头文件CRB.h中：

```c
CRB_Interpreter *CRB_create_interpreter(void);
```

``` CRB_create_interpreter() ``` 返回值的类型为 ``` CRB_Interpreter* ```，为了支持这样的原型定义必须首先定义``` CRB_Interpreter ```结构体。但是我们不能把解释器的内部定义直接拿出来放在公有头文件中。  
应对这种情况可以使用不完全类型。公有头文件中只定义结构体的标识符，实际的定义是由私有头文件传递给公有头文件的。
比如上面的``` CRB_Interpreter ``` 类型，在CRB.h中可以做如下的标识符定义，并用typedef命名。  

```c 
typedef struct CRB_Interpreter_tag CRB_Interpreter;
```
这种状态的CRB_Interpreter就是不完全类型。
不完全类型只能使用指针，即指向不完全类型的指针的变量无法被声明，不完全类型本身也无法声明变量，对不完全类型无法使用sizeof。因此，我们是无法知道一个不完全类型的大小的，当然也无法引用其成员。

---



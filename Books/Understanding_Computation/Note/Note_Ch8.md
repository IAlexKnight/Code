# Chpater 8 Computablity

### 可以永远循环的通用系统
不管系统有什么特性，不停机程序是通用性的一个不可避免的结果。我们的观点除了依赖Ruby的通用性之外不依赖Ruby的任何特殊能力，因此同样的思想也可以适用于图灵机，或者lambda运算，或者任何其他的通用系统，只要再使用一种强大到能对自身求值的语言，我们就知道一定可能使用```#evaluate```的等价物构建永不停机程序，而不需要知道关于语言能力的任何其他东西。   
特别地，在编程语言中移除特性（如while循环）并不能阻止我们在保持语言足以通用的同时还能写出不停机的程序来。如果移除了一个特性让一个程序无法永远循环，一定也不能实现```#evaluate```了。  
被仔细地设计以保证它们的程序一定总是能停机的语言叫做完全编程语言，与之相对的是更常见的部分编程语言，这样语言的程序有时候能停机给出答案，有时候不能。完全变成语言仍然非常强大，能表达许多有用的计算，但它们不能做到的就是解释自身。   

- 这很奇怪，虽然对一种完全编程语言，从定义上来说```#evaluate```的等价物一定总是能停机的，但用那种语言是无法实现的——如果它可以实现的话，我们就能使用```does_it_say_no.rb```技术让它永远循环了。   
这让我们对一个不可能程序有了初步了解：无法用完全编程语言写一个对其自身的解释器，即使为了解释它存在一个令人尊敬的保证能停机的算法也不行，事实上，它是如此令人尊敬以至于我们能用另一种更复杂的编程语言写出来，但这个新的完全编程语言也不能实现它自己的解释器。  
虽然是个有意思的东西，但完全编程语言的设计有人为的限制；我们一直在寻找所有计算机或者编程语言不能完成的东西。

### 其他不可判定问题

Rice定理：程序行为的任何非平凡性质都是不可判定的，因为停机问题总是能被规约成判定这个属性是否为true的问题；如果我们能发明一个算法来判定那个属性，就能使用它来构建另一个算法来判定停机问题，而这是不可能的。

- 概括的讲，一个“非平凡的属性“是对程序做什么而不是程序怎么做的一个要求。例如，Rice定理对于像“这个程序的源代码包含字符串‘reverse’吗？”这种问题并不适用，因为这是一个实现细节，能在不改变程序外部可视行为的前提吓人重构掉。换句话说，像”这个程序是输出它输入的逆向吗？”这样的语义性质是在Rice定理范围内的，从而是不可判定的。

Rice定理告诉我们存在大量关于一个程序执行时会干什么的不可判定的问题。

### 令人沮丧的暗示
能力不受限制的编程语言与下厨程序产生一个不会陷入无限循环的结果之间取舍。   
不知“程序是否会停机”是不可判定的，“程序是否做了我想让它做的”也是不可判定的。    
一言以蔽之，程序行为这么难预测有两个原因：  
1.任何拥有足够能力引用自身的系统，都无法正确回答每一个关于自身的问题。
2.但是对于通用编程语言，不存在更强大的系统供我们升级。

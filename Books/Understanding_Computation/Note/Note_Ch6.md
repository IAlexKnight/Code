# Chapter 6 无类型lambda演算

通过lambda演算实现一个非常有限的特性集合，并且使用它自己的解析器、抽象语法和操作语义来把它们实现为一种语言。

---

- 使用最小Ruby来进行编程，使用proc来进行构建：
	- 管道
	- 参数（多参数转换为单参数）
	- 等价（外延等价）
	- 语法 -> argument { body }

---

实现FizzBuzz：


- 数字（非负整数）
	- 将数据表示为纯代码的技术称为Church Encoding, 通过迭代的当时从0表达至infinity  
<br>

- 布尔值
	- TRUE 和 FALSE 在两个选项之间做出选择，而IF则是直接返回proc（装饰作用）  
<br>

- 谓词 
	- 对于判断是否为0的关键在于是否调用了proc  
<br>
	  

- 有序对  
	- 为实现DECREMENT做准备   
<br>

- 数值运算
 	- 取模运算  
 	在避免了无穷递归的问题之后，会发现我们在用常量MOD定义常量MOD，因此这个定义不只是一个缩写。这次我们不仅仅在把一个复杂的proc赋值给一个常量以便之后重用。事实上，我们以来Ruby的赋值语义，尽管仍然在定义MOD，但它很明显还没有被定义，然而我们可以在MOD的实现中引用它，并期望在之后对其求值的时候它已经被定义了。  
	但这实际上是在欺骗，因为原则上我们应该能够撤销掉所有的缩写——“我们提到MOD的地方，实际的意思是这个长长的proc”——但只要MOD由其自身定义这就不可能。  
	所以这就需要一个非常“awesome”的东西——Y组合子（涉及内容较多，另起篇幅）:		
	
			λf.(λx.f(x x))(λx.f(x x))  
			
			Y = -> f { -> x { f[x[x]] }[ -> x { f[x[x]] }] }
		

	由于和MOD无穷递归一样，Y组合子也会在Ruby中无穷递归，所以有了Z组合子，本质上是Y组合子对Ruby这样严格语言的变换：
	
			Z = -> f { -> x { f[-> y { x[x][y] }] }[-> x { f [-> y { x[x][y] }] }] }

			
---
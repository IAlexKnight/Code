# Part 1 （ch2 - ?） 程序和机器
- **计算**？  
	1.机器 
	2.语言 
	3.程序  
<br>

- 描述编程语言  
	1.解释器/编译器	
	2.官方规范  
	3.形式语义（数学方法）
---


操作语义
---
- 小步语义（结构化操作语义/转换语义）  
	一小步一小步进行规约  
	<br>
	
	
- Simple 语言实现  
	- 表达式  
	- 语句
	- 正确性
	

>
	循环结构（while）的实现：
	每一步归约要想与将来的归约步骤交流，只能通过产生一个新的语句和环境来实现，而使用这种方法（规约之后在判断），我们就没有地方记录最初的条件和语句主体供下一个循环使用  
	小步的解决方式是使用序列语句将《while》的一个级别展开，把它规约成一个只执行一次循环的《If》语句，然后再重复原始的《while》。


<br>
   
- 大步语义（自然语义/关联语义）  
	定义如何从一个表达式直接或者语句直接得到它的结果。这必然需要把程序的执行当成一个递归而不是迭代（尾递归）的过程。	
	小步语义明确定义了操作应该发生的顺序，在每一步都明确了下一步规约应该是什么。但是大步语义经常会写成更松散的形式，只说哪些自运算会执行，而不会指明它们按什么顺序执行。
	
>
	大步语义在定义真正程序设计语言行最有影响的应用是标准ML编程语言的原始定义，它用大步语义放肆定义了ML的所有运行时行为。在这个例子之后，OCam的核心语言用大步语义补足了它更细节的小步定义。

	
-  **操作语义实际上是这样的：通过描述一个解析器来说明一种语言的含义。有一种操作语义的替换形式，叫作规约语义，它通过引入所谓的关系上下文，把“下一步规约什么”和“如何对其进行规约”分离开来，这些上下文只是一些简明描述了规约在程序中何处发生的模式。这意味着我们只需要执行计算的规约规则，从而把一些样板文件从更大型的语言中去掉。**

<br>

 
 ---
 
 
指称语义 (denotational semantic)
---

<br>

- 不动点语义/数学语义

- 指称语义关心从程序本来的语言到其他表示的转换。(用另一种语言重写)

>
	这意味着我们已经把理解Simple的问题转换成了理解指称语言的问题，而如果指称语言像Ruby一样庞大而且定义不良，这就是一个严重的缺点；但在有一个能用来写指称的小型数学语言时，这就成了一个优点
 
 
---
 
形式化语义实践
---
 
- 找到含义  
	形式化语义的一个重要应用是为一种编程语言的含义给出一个无歧义的定义，而不是让其依赖于像自然语言规范文档和“由实现规范”这样更加随意的方法。  
	指称语义的一个优点是比操作语义抽象层次更高，它忽略了程序如何执行的细节，而只关心如何把它转换成一个不同的表示，例如，如果存在一种指称语义可以把两种语言翻译成某种共通的表示，就使对不同语言写成的两个程序进行比较成为可能。
	形式化的指称语义使用抽象的数学对象（通常是函数）来表示表达式和语句这样的编程语言结构，并且因为数学上的约定会规定如何对函数求值这样的事情，这就有了一种直接在操作语义上思考指称的方式。
 
 
 - 除了上述语义之外，还有其他类型的语义可用，其中一个就是公理化语义。它通过在语句执行前后分别给出抽象机器的状态的断言来描述一个语句的含义：如果一个断言（前置条件）在语句执行前初始是true，那么随后其他断言（后置条件）将是true。公理化语义在验证程序正确性方面很有用：随着语句合到一起组成更大的程序，它们对应的断言也能合到一起组成更大的断言，其目标就是表明对一个程序总体的断言与它的预期定义匹配。
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 